"use strict";(self.webpackChunkltx_docs=self.webpackChunkltx_docs||[]).push([[959],{5488:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"welcome/Singletons","title":"\ud83d\udccc\ufe0f Singletons","description":"We all love singletons, right?","source":"@site/docs/0_welcome/Singletons.md","sourceDirName":"0_welcome","slug":"/welcome/Singletons","permalink":"/Docs/welcome/Singletons","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"\ud83d\udccc\ufe0f Singletons"},"sidebar":"tutorialSidebar","previous":{"title":"\ufe0f\u2699\ufe0f Tools ","permalink":"/Docs/welcome/Tools"},"next":{"title":"\ud83d\udce1 Channeled Properties","permalink":"/Docs/welcome/Channeled-Properties"}}');var s=t(4848),i=t(8453);const r={sidebar_position:2,title:"\ud83d\udccc\ufe0f Singletons"},l=void 0,c={},a=[];function d(e){const n={br:"br",code:"code",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["We all love singletons, right?",(0,s.jsx)(n.br,{}),"\n","The ",(0,s.jsx)(n.strong,{children:"Singletons"})," package offers a flexible way to use singletons in your game, providing ",(0,s.jsx)(n.strong,{children:"three main methods"})," to access them:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Classic"}),": Create a singleton that doesn't inherit from MonoBehaviour."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MonoSingleton"}),": Create a MonoBehaviour singleton designed to be instantiated ",(0,s.jsx)(n.strong,{children:"at runtime"}),". Once awake, the MonoSingleton moves to the ",(0,s.jsx)(n.code,{children:"DontDestroyOnLoad"})," scene to persist across scene loads."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SceneSingleton"}),": What if you just want to access a unique object in your scene (or across all loaded scenes)? The SceneSingleton lets you do exactly that, by preventing the singleton from being created from scratch and instead accessing the instance already present in any open scene."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This package gives you the flexibility to choose the singleton pattern that best fits your needs, whether global or scene-specific."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Price: Free"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);