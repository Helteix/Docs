"use strict";(self.webpackChunkltx_docs=self.webpackChunkltx_docs||[]).push([[621],{1660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"welcome/NodeGraph","title":"\ud83e\udde9 Node Graph","description":"We all love singletons, right?","source":"@site/docs/0_welcome/NodeGraph.md","sourceDirName":"0_welcome","slug":"/welcome/NodeGraph","permalink":"/welcome/NodeGraph","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"\ud83e\udde9 Node Graph"},"sidebar":"tutorialSidebar","previous":{"title":"\ud83d\udce1 Channeled Properties","permalink":"/welcome/Channeled-Properties"},"next":{"title":"\ud83e\udd1d Support","permalink":"/welcome/What\'s next"}}');var s=t(4848),r=t(8453);const i={sidebar_position:4,title:"\ud83e\udde9 Node Graph"},a=void 0,c={},l=[];function d(e){const n={br:"br",code:"code",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["We all love singletons, right?",(0,s.jsx)(n.br,{}),"\n","The ",(0,s.jsx)(n.strong,{children:"Singletons"})," package offers a flexible way to use singletons in your game, providing ",(0,s.jsx)(n.strong,{children:"three main methods"})," to access them:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Classic"}),": Create a singleton that doesn't inherit from MonoBehaviour."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MonoSingleton"}),": Create a MonoBehaviour singleton designed to be instantiated ",(0,s.jsx)(n.strong,{children:"at runtime"}),". Once awake, the MonoSingleton moves to the ",(0,s.jsx)(n.code,{children:"DontDestroyOnLoad"})," scene to persist across scene loads."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SceneSingleton"}),": What if you just want to access a unique object in your scene (or across all loaded scenes)? The SceneSingleton lets you do exactly that, by preventing the singleton from being created from scratch and instead accessing the instance already present in any open scene."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This package gives you the flexibility to choose the singleton pattern that best fits your needs, whether global or scene-specific."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Price: Free"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6540);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);